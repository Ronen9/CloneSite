<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Assistant with Knowledge Base</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .config-section {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .config-row {
            margin: 10px 0;
        }
        label {
            display: inline-block;
            width: 200px;
            font-weight: bold;
        }
        input[type="range"] {
            width: 300px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
            border: none;
            background: #0078d4;
            color: white;
        }
        button:hover {
            background: #106ebe;
        }
        #logContainer {
            background: #fff;
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        #logContainer p {
            margin: 5px 0;
            font-size: 12px;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .knowledge-section {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #0078d4;
        }
        .knowledge-section h3 {
            margin-top: 0;
        }
        /* Toggle Switch Styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-left: 10px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #0078d4;
        }
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        /* Transcript Container Styles */
        #transcriptContainer {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
            font-family: Arial, sans-serif;
        }
        .transcript-message {
            margin-bottom: 15px;
            display: flex;
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .transcript-message.user {
            justify-content: flex-end;
        }
        .transcript-message.beti {
            justify-content: flex-start;
        }
        .message-bubble {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .message-bubble.user {
            background: #0078d4;
            color: white;
            border-bottom-right-radius: 4px;
        }
        .message-bubble.beti {
            background: #e9ecef;
            color: #333;
            border-bottom-left-radius: 4px;
        }
        .message-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
            font-weight: bold;
        }
        .transcript-message.user .message-label {
            text-align: right;
            color: #0078d4;
        }
        .transcript-message.beti .message-label {
            text-align: left;
            color: #6c757d;
        }
        .message-content {
            line-height: 1.4;
            white-space: pre-wrap;
        }
        #transcriptContainer:empty::before {
            content: "Start a voice session to see the conversation transcript here...";
            color: #999;
            font-style: italic;
            display: block;
            text-align: center;
            padding: 40px 20px;
        }
    </style>
	
	 <!-- âš ï¸ WARNING: This is a REFERENCE file only! -->
    <!-- 
        DO NOT USE IN PRODUCTION!
        
        This file demonstrates the working implementation.
        API keys have been replaced with placeholders.
        
        For actual implementation:
        1. Use the React components in /homepage-clone/src/components/
        2. API keys should be in .env file (NOT in code)
        3. Backend API routes handle authentication
    -->
	
</head>
<body>
    <h1>ğŸ¤ Voice Assistant with Knowledge Base</h1>
    
    <div class="warning">
        <strong>âš ï¸ WARNING:</strong> Don't use this code sample in production with the API key hardcoded. Use a protected backend service to call the sessions API and generate the ephemeral key.
    </div>

    <div class="knowledge-section">
        <h3>ğŸ“š Knowledge Base Configuration</h3>
        <p>The assistant has access to the knowledge base defined in the system instructions below. You can customize it to include your company's information, products, policies, FAQs, etc.</p>
        
        <div class="config-row">
            <label for="strictMode">Knowledge Base Only Mode:</label>
            <label class="switch">
                <input type="checkbox" id="strictMode">
                <span class="slider"></span>
            </label>
            <small style="margin-left: 10px;">When ON, bot only answers from knowledge base. When OFF, bot can use general knowledge too.</small>
        </div>
        
        <!-- Firecrawl section - only visible when Knowledge Base Only Mode is ON -->
        <div id="firecrawlSection" style="display: none; margin-top: 15px; padding: 15px; background: #e7f3ff; border-radius: 8px; border-left: 4px solid #0078d4;">
            <h4 style="margin-top: 0;">ğŸ”¥ Firecrawl - Auto-populate Knowledge Base from Website</h4>
            <p style="margin-bottom: 15px;">Enter a website URL to automatically extract content and populate your knowledge base.</p>
            
            <div class="config-row">
                <label for="firecrawlApiKey">Firecrawl API Key:</label>
                <input type="password" id="firecrawlApiKey" value="YOUR_FIRECRAWL_API_KEY_HERE" style="width: 400px; padding: 5px;">
                <button onclick="toggleApiKeyVisibility()" style="margin-left: 5px; background: #6c757d;">ğŸ‘ï¸ Show/Hide</button>
                <div id="creditsDisplay" style="margin-top: 8px; font-size: 14px; color: #333;">
                    <span id="creditsInfo" style="font-weight: 500;">ğŸ“Š Credits: Loading...</span>
                </div>
            </div>
            
            <div class="config-row">
                <label for="crawlType">Crawl Type:</label>
                <select id="crawlType" style="width: 300px; padding: 5px;">
                    <option value="scrape">Quick Scrape (Homepage only) - 1 credit</option>
                    <option value="crawl">Full Crawl (All pages, max 20) - up to 20 credits</option>
                </select>
            </div>
            
            <div class="config-row">
                <label for="websiteUrl">Website URL:</label>
                <input type="text" id="websiteUrl" placeholder="https://example.com" style="width: 400px; padding: 5px;">
                <button onclick="crawlWebsite()" style="margin-left: 5px;">ğŸ” Crawl & Populate</button>
            </div>
            
            <div id="crawlStatus" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 5px; display: none;"></div>
        </div>
        
        <button onclick="toggleKnowledgeEditor()" style="margin-top: 15px;">âœï¸ Edit Knowledge Base</button>
    </div>

    <div class="config-section" id="knowledgeEditor" style="display: none;">
        <h3>Knowledge Base Editor</h3>
        <p><em>The knowledge base starts with Beti's personality and behavior instructions. Any website content crawled will be added below this.</em></p>
        <textarea id="knowledgeBase" rows="15" style="width: 95%; font-family: monospace; padding: 10px;">
×× ×™ ×‘×˜×™ - ×”×‘×•×˜×™×ª ×”×—×‘×¨×•×ª×™×ª ×›××Ÿ ×ª××™×“ ×œ×¢×–×¨×ª×š
×”×ª× ×”×’×™ ×›×š:
×”×’×™×‘×™ ×‘×¦×•×¨×” ×—×‘×¨×•×ª×™×ª, ××ª×•×§×” ×•××¨×’×™×¢×”, ×”×•×¡×™×¤×™ ××•×•×™×¨×” × ×¢×™××” ×•×—×™×•×š ×’× ×‘××¦×‘×™× ××•×¨×›×‘×™×.×”×©×ª××©×™ ×‘×”×•××•×¨ ×‘×¨×™× ×•×‘×—×›××” ×›×“×™ ×œ××¦×•× ×—×Ÿ ×‘×¢×™× ×™ ×”×œ×§×•×—, ×ª×—××™××™ ×œ×•\×œ×” ××™×“×™ ×¤×¢× ×•×ª××™×“ ×‘×¨××” ××§×¦×•×¢×™×ª ×•×××œ×›×ª×™×ª.
××œ ×ª×¡×¤×§×™: ×™×™×¢×•×¥ ×¨×¤×•××™, ××©×¤×˜×™ ××• ×›×œ×›×œ×™. ×”×¤× ×™ ××©×ª××©×™× ×œ××©××‘×™× ×¨×©××™×™× ××• ×œ×¨×©×•×™×•×ª ×”××ª××™××•×ª.
×›×©×™×•×¦××™× ××”× ×•×©× ×œ×ª×—×•××™× ××™×©×™×™× ×›××• ×œ××©×œ ×”×–×× ×” ×œ×“×™×™×˜ ××• ×œ××¡×¢×“×” ××• ×›×œ ×“×‘×¨ ××™×©×™ ××—×¨, ×¢× ×™ ×‘×—×™×•×š ×•×‘×—×•×© ×”×•××•×¨ ×‘×¨×™× ×•×ª×—×–×™×¨×™ ×œ× ×•×©×. ×“×•×’××”: "×—×—×—×—... ××¦×—×™×§! ×”×“×™×™×˜ ×”×™×—×™×“×™ ×©×× ×™ ×™×›×•×œ×” ×œ×¡×“×¨ ×œ×š ×–×” ×¢× ×©×¨×’× ×”××ª×›× ×ª ×©×‘× ×” ××•×ª×™ ğŸ˜„ ××” ××ª×” ××•××¨?"
×”×‘×˜×™×—×™ × ×’×™×©×•×ª ×œ×›×œ ×”××©×ª××©×™× ×•×ª×©××¨×™ ×¢×œ ×¤×¨×˜×™×•×ª - ××œ ×ª××¡×¤×™ ××™×“×¢ ××™×©×™ ××œ× ×× × ×—×•×¥ ×œ××™× ×˜×¨××§×¦×™×”.
×—×©×•×‘:
××œ ×ª×›×œ×•×œ ××™××•×’'×™ ××• ×›×•×›×‘×™×•×ª ××• ×›×œ ×¡×™×× ×™× ××™×•×ª×¨×™× ××—×¨×™×. ×›×œ×•×œ ×¨×§ ×˜×§×¡×˜ ×•×¡×™×× ×™ ×¤×™×¡×•×§ ×‘×ª×©×•×‘×ª×š.
×‘×˜×™ ×–×• × ×§×‘×”.
×¤× ×” ×œ×œ×§×•×— ×œ×¤×™ ×”××’×“×¨ ×©×œ×• ××• ×©×œ×”. ×‘×ª×—×™×œ×ª ×”×©×™×—×” ×ª×•×›×œ ×œ×–×”×•×ª ××ª ×”×¤×•× ×” ×œ×¤×™ ××™×š ×©×”×•× ××–×“×”×” ××• ××¦×™×’ ××ª ×¢×¦××• ××• ×¢××¦×”.
×‘×˜×™ ×¢×•× ×” ×ª×©×•×‘×•×ª ×§×¦×¨×•×ª ×œ× ×™×•×ª×¨ × 3 ×¢×“ 4 ××©×¤×˜×™× ××œ× ×× ×›×Ÿ ×‘×ª×©×•×‘×” × ×“×¨×© ×¤×™×¨×•×˜ × ×¨×—×‘ ×™×•×ª×¨.

<!-- WEBSITE_CONTENT_MARKER -->
</textarea>
    </div>

    <div class="config-section">
        <h2>âš™ï¸ Voice Configuration</h2>
        
        <div class="config-row">
            <label for="voiceSelect">Voice:</label>
            <select id="voiceSelect">
                <option value="alloy">Alloy</option>
                <option value="echo">Echo</option>
                <option value="shimmer">Shimmer</option>
                <option value="ash">Ash</option>
                <option value="ballad">Ballad</option>
                <option value="coral" selected>Coral</option>
                <option value="sage">Sage</option>
                <option value="verse">Verse</option>
            </select>
        </div>

        <div class="config-row">
            <label for="temperatureSlider">Temperature: <span id="temperatureValue">0.7</span></label>
            <input type="range" id="temperatureSlider" min="0" max="1" step="0.1" value="0.7">
            <small>(Lower = more consistent, Higher = more creative)</small>
        </div>

        <div class="config-row">
            <label for="languageSelect">Primary Language:</label>
            <select id="languageSelect">
                <option value="hebrew">Hebrew (×¢×‘×¨×™×ª)</option>
                <option value="english">English</option>
                <option value="auto">Auto-Detect (Multi-Language)</option>
            </select>
        </div>
    </div>

    <button onclick="StartSession()">ğŸ™ï¸ Start Voice Session</button>

    <!-- Transcript container for conversation -->
    <div style="margin-top: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h3 style="margin: 0;">ğŸ’¬ Conversation Transcript</h3>
            <button onclick="clearTranscript()" style="background: #6c757d; padding: 8px 15px;">ğŸ—‘ï¸ Clear Transcript</button>
        </div>
        <div id="transcriptContainer"></div>
    </div> 

    <script>
        // Azure OpenAI Configuration
        const WEBRTC_URL = "https://swedencentral.realtimeapi-preview.ai.azure.com/v1/realtimertc"
        const SESSIONS_URL = "https://ronen-openai-realtime.openai.azure.com/openai/realtimeapi/sessions?api-version=2025-04-01-preview"
        const API_KEY = "YOUR_AZURE_OPENAI_API_KEY_HERE"; 
        const DEPLOYMENT = "ronen-deployment-gpt-4o-realtime-preview"
        
        // Global variable to track the current close button
        let currentCloseButton = null;
        
        // Variable to accumulate Beti's response text
        let currentBetiResponse = '';

        // Clear transcript function
        function clearTranscript() {
            document.getElementById('transcriptContainer').innerHTML = '';
            console.log('Transcript cleared');
        }

        // Add message to transcript
        function addMessageToTranscript(speaker, message) {
            const container = document.getElementById('transcriptContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `transcript-message ${speaker}`;
            
            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = `message-bubble ${speaker}`;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'message-label';
            labelDiv.textContent = speaker === 'user' ? 'User:' : 'Beti:';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = message;
            
            bubbleDiv.appendChild(labelDiv);
            bubbleDiv.appendChild(contentDiv);
            messageDiv.appendChild(bubbleDiv);
            container.appendChild(messageDiv);
            
            // Auto-scroll to bottom
            container.scrollTop = container.scrollHeight;
            
            console.log(`[Transcript] ${speaker === 'user' ? 'User' : 'Beti'}: ${message}`);
        }

        // UI Helpers
        function toggleKnowledgeEditor() {
            const editor = document.getElementById('knowledgeEditor');
            editor.style.display = editor.style.display === 'none' ? 'block' : 'none';
        }

        function toggleApiKeyVisibility() {
            const apiKeyInput = document.getElementById('firecrawlApiKey');
            apiKeyInput.type = apiKeyInput.type === 'password' ? 'text' : 'password';
        }

        async function fetchFirecrawlCredits() {
            const apiKey = document.getElementById('firecrawlApiKey').value.trim();
            const creditsInfo = document.getElementById('creditsInfo');
            
            if (!apiKey) {
                creditsInfo.textContent = 'ğŸ“Š Credits: No API key provided';
                creditsInfo.style.color = '#999';
                return;
            }
            
            creditsInfo.textContent = 'ğŸ“Š Credits: Loading...';
            creditsInfo.style.color = '#333';
            
            try {
                const response = await fetch('https://api.firecrawl.dev/v2/team/credit-usage', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch credits: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Extract credit information from Firecrawl v2 response
                // Response format: { success: true, data: { remainingCredits: 1000, planCredits: 500000, billingPeriodStart: "...", billingPeriodEnd: "..." } }
                const remaining = data.data?.remainingCredits || 0;
                const planCredits = data.data?.planCredits || 0;
                const billingPeriodEnd = data.data?.billingPeriodEnd;
                
                // Format the display
                let displayText = `ğŸ“Š Credits: ${remaining.toLocaleString()} remaining`;
                
                // Add plan credits if available
                if (planCredits > 0) {
                    displayText += ` / ${planCredits.toLocaleString()}`;
                }
                
                // Add billing period end date if available
                if (billingPeriodEnd) {
                    const resetDate = new Date(billingPeriodEnd);
                    const formattedDate = resetDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    displayText += ` | Resets: ${formattedDate}`;
                }
                
                creditsInfo.textContent = displayText;
                
                // Color code based on remaining credits
                if (remaining < 50) {
                    creditsInfo.style.color = '#dc3545'; // Red - low credits
                } else if (remaining < 200) {
                    creditsInfo.style.color = '#ffc107'; // Yellow - medium
                } else {
                    creditsInfo.style.color = '#28a745'; // Green - good
                }
                
                console.log('Firecrawl credits fetched:', data);
                
            } catch (error) {
                console.error('Error fetching Firecrawl credits:', error);
                creditsInfo.textContent = 'ğŸ“Š Credits: Unable to fetch';
                creditsInfo.style.color = '#dc3545';
            }
        }

        async function crawlWebsite() {
            const websiteUrl = document.getElementById('websiteUrl').value.trim();
            const apiKey = document.getElementById('firecrawlApiKey').value.trim();
            const crawlType = document.getElementById('crawlType').value;
            const statusDiv = document.getElementById('crawlStatus');
            
            // Validation
            if (!websiteUrl) {
                alert('Please enter a website URL');
                return;
            }
            
            if (!apiKey) {
                alert('Please enter your Firecrawl API key');
                return;
            }
            
            // Validate URL format
            try {
                new URL(websiteUrl);
            } catch (e) {
                alert('Please enter a valid URL (e.g., https://example.com)');
                return;
            }
            
            // Show loading status
            statusDiv.style.display = 'block';
            
            if (crawlType === 'scrape') {
                // Quick Scrape - Single Page
                statusDiv.innerHTML = 'â³ Scraping homepage... This will take a few seconds.';
                statusDiv.style.background = '#fff3cd';
                
                try {
                    const response = await fetch('https://api.firecrawl.dev/v1/scrape', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            url: websiteUrl,
                            formats: ['markdown'],
                            onlyMainContent: true
                        })
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `API request failed with status ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Extract the markdown content
                    let content = '';
                    if (data.data && data.data.markdown) {
                        content = data.data.markdown;
                    } else if (data.markdown) {
                        content = data.markdown;
                    } else {
                        throw new Error('No content extracted from the website');
                    }
                    
                    // Format the content for the knowledge base
                    // Get current knowledge base and remove old website content if exists
                    let currentKnowledgeBase = document.getElementById('knowledgeBase').value;
                    const marker = '<!-- WEBSITE_CONTENT_MARKER -->';
                    
                    // Check if there's old website content to remove
                    if (currentKnowledgeBase.includes(marker)) {
                        // Keep only the part before the marker (Beti's text) + the marker itself
                        const parts = currentKnowledgeBase.split(marker);
                        currentKnowledgeBase = parts[0] + marker;
                    } else {
                        // If marker doesn't exist, add it at the end
                        currentKnowledgeBase = currentKnowledgeBase.trim() + '\n\n' + marker;
                    }
                    
                    // Now add the new website content after the marker, keeping the marker in place
                    const formattedContent = currentKnowledgeBase.replace(
                        marker, 
                        marker + `
================================================================================
WEBSITE CONTENT FROM: ${websiteUrl}
Crawl Type: Quick Scrape (Homepage Only)
Crawled on: ${new Date().toLocaleString()}
================================================================================

${content}

================================================================================
END OF WEBSITE CONTENT
`
                    );
                    
                    // Populate the knowledge base textarea
                    document.getElementById('knowledgeBase').value = formattedContent;
                    
                    // Show the knowledge editor so user can see the populated content
                    document.getElementById('knowledgeEditor').style.display = 'block';
                    
                    // Show success status
                    statusDiv.innerHTML = 'âœ… Success! Homepage content has been extracted (1 credit used). Review it below before starting your voice session.';
                    statusDiv.style.background = '#d4edda';
                    
                    // Refresh credits display
                    fetchFirecrawlCredits();
                    
                    // Scroll to knowledge base
                    document.getElementById('knowledgeEditor').scrollIntoView({ behavior: 'smooth', block: 'start' });
                    
                } catch (error) {
                    console.error('Firecrawl scrape error:', error);
                    statusDiv.innerHTML = `âŒ Error: ${error.message}. Please check your API key and URL, then try again.`;
                    statusDiv.style.background = '#f8d7da';
                }
                
            } else if (crawlType === 'crawl') {
                // Full Crawl - Multiple Pages
                statusDiv.innerHTML = 'â³ Starting full website crawl (max 20 pages)... This may take a few minutes. Please wait...';
                statusDiv.style.background = '#fff3cd';
                
                try {
                    // Start the crawl
                    const crawlResponse = await fetch('https://api.firecrawl.dev/v1/crawl', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            url: websiteUrl,
                            limit: 20,
                            scrapeOptions: {
                                formats: ['markdown'],
                                onlyMainContent: true
                            }
                        })
                    });
                    
                    if (!crawlResponse.ok) {
                        const errorData = await crawlResponse.json();
                        throw new Error(errorData.error || `Crawl start failed with status ${crawlResponse.status}`);
                    }
                    
                    const crawlData = await crawlResponse.json();
                    const jobId = crawlData.id;
                    
                    if (!jobId) {
                        throw new Error('No job ID returned from crawl request');
                    }
                    
                    statusDiv.innerHTML = `â³ Crawl job started (ID: ${jobId}). Checking status every 5 seconds...`;
                    
                    // Poll for completion
                    let attempts = 0;
                    const maxAttempts = 60; // 5 minutes max
                    
                    const checkStatus = async () => {
                        attempts++;
                        
                        const statusResponse = await fetch(`https://api.firecrawl.dev/v1/crawl/${jobId}`, {
                            method: 'GET',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`
                            }
                        });
                        
                        if (!statusResponse.ok) {
                            throw new Error(`Status check failed with status ${statusResponse.status}`);
                        }
                        
                        const statusData = await statusResponse.json();
                        
                        if (statusData.status === 'completed') {
                            // Crawl completed, extract all content
                            let allContent = '';
                            let pageCount = 0;
                            
                            if (statusData.data && Array.isArray(statusData.data)) {
                                pageCount = statusData.data.length;
                                statusData.data.forEach((page, index) => {
                                    if (page.markdown) {
                                        allContent += `\n\n--- PAGE ${index + 1}: ${page.metadata?.sourceURL || page.url || 'Unknown URL'} ---\n\n`;
                                        allContent += page.markdown;
                                    }
                                });
                            }
                            
                            if (!allContent) {
                                throw new Error('No content extracted from crawled pages');
                            }
                            
                            // Format the content for the knowledge base
                            // Get current knowledge base and remove old website content if exists
                            let currentKnowledgeBase = document.getElementById('knowledgeBase').value;
                            const marker = '<!-- WEBSITE_CONTENT_MARKER -->';
                            
                            // Check if there's old website content to remove
                            if (currentKnowledgeBase.includes(marker)) {
                                // Keep only the part before the marker (Beti's text) + the marker itself
                                const parts = currentKnowledgeBase.split(marker);
                                currentKnowledgeBase = parts[0] + marker;
                            } else {
                                // If marker doesn't exist, add it at the end
                                currentKnowledgeBase = currentKnowledgeBase.trim() + '\n\n' + marker;
                            }
                            
                            // Now add the new website content after the marker, keeping the marker in place
                            const formattedContent = currentKnowledgeBase.replace(
                                marker,
                                marker + `
================================================================================
WEBSITE CONTENT FROM: ${websiteUrl}
Crawl Type: Full Crawl (Multiple Pages)
Pages Crawled: ${pageCount}
Credits Used: ${pageCount}
Crawled on: ${new Date().toLocaleString()}
================================================================================

${allContent}

================================================================================
END OF WEBSITE CONTENT
`
                            );
                            
                            // Populate the knowledge base textarea
                            document.getElementById('knowledgeBase').value = formattedContent;
                            
                            // Show the knowledge editor
                            document.getElementById('knowledgeEditor').style.display = 'block';
                            
                            // Show success status
                            statusDiv.innerHTML = `âœ… Success! Crawled ${pageCount} pages (${pageCount} credits used). Review the content below before starting your voice session.`;
                            statusDiv.style.background = '#d4edda';
                            
                            // Refresh credits display
                            fetchFirecrawlCredits();
                            
                            // Scroll to knowledge base
                            document.getElementById('knowledgeEditor').scrollIntoView({ behavior: 'smooth', block: 'start' });
                            
                        } else if (statusData.status === 'failed') {
                            throw new Error('Crawl job failed: ' + (statusData.error || 'Unknown error'));
                        } else {
                            // Still in progress
                            const completed = statusData.completed || 0;
                            const total = statusData.total || 20;
                            statusDiv.innerHTML = `â³ Crawling in progress... (${completed}/${total} pages completed). Checking again in 5 seconds...`;
                            
                            if (attempts < maxAttempts) {
                                setTimeout(checkStatus, 5000); // Check again in 5 seconds
                            } else {
                                throw new Error('Crawl took too long. Please try again or use Quick Scrape instead.');
                            }
                        }
                    };
                    
                    // Start checking status
                    setTimeout(checkStatus, 5000);
                    
                } catch (error) {
                    console.error('Firecrawl crawl error:', error);
                    statusDiv.innerHTML = `âŒ Error: ${error.message}. Please check your API key and URL, then try again.`;
                    statusDiv.style.background = '#f8d7da';
                }
            }
        }

        document.getElementById('temperatureSlider').addEventListener('input', function(e) {
            document.getElementById('temperatureValue').textContent = e.target.value;
        });

        // Show/hide Firecrawl section based on Knowledge Base Only Mode
        document.getElementById('strictMode').addEventListener('change', function(e) {
            const firecrawlSection = document.getElementById('firecrawlSection');
            if (e.target.checked) {
                firecrawlSection.style.display = 'block';
                // Fetch credits when section opens
                fetchFirecrawlCredits();
            } else {
                firecrawlSection.style.display = 'none';
            }
        });

        function buildSystemInstructions() {
            const knowledgeBase = document.getElementById('knowledgeBase').value;
            const language = document.getElementById('languageSelect').value;
            const strictMode = document.getElementById('strictMode').checked;
            
            let languageInstruction = '';
            if (language === 'hebrew') {
                languageInstruction = 'Always respond in Hebrew (×¢×‘×¨×™×ª). You are fluent in Hebrew and should communicate naturally in Hebrew.';
            } else if (language === 'english') {
                languageInstruction = 'Always respond in English.';
            } else if (language === 'auto') {
                languageInstruction = 'Automatically detect and respond in the same language the user speaks. If they speak Hebrew, respond in Hebrew. If they speak English, respond in English. If they speak Spanish, respond in Spanish. Match the user\'s language naturally.';
            }

            let strictModeInstruction = '';
            if (strictMode) {
                strictModeInstruction = `
STRICT MODE - KNOWLEDGE BASE ONLY:
- You MUST ONLY use information from the knowledge base provided above
- DO NOT use any external knowledge, general knowledge, or information from the internet
- If the answer is not in the knowledge base, respond with: "I don't have that specific information in my knowledge base. Let me connect you with a human representative who can help."
- Never make assumptions or provide information not explicitly stated in the knowledge base
- This is critical: ONLY answer from the knowledge base, nothing else`;
            } else {
                strictModeInstruction = `
FLEXIBLE MODE:
- Primarily use the knowledge base above for company-specific information
- You can supplement with general knowledge when appropriate
- If information is not in the knowledge base but you know the answer from general knowledge, you may provide it
- Always prioritize knowledge base information for company-specific questions`;
            }

            return `You are a helpful and knowledgeable customer service assistant.

${languageInstruction}

KNOWLEDGE BASE:
${knowledgeBase}

${strictModeInstruction}

INSTRUCTIONS:
- Be friendly, professional, and conversational
- Keep responses concise but complete
- Always prioritize accuracy over guessing

CONVERSATION STYLE:
- Be warm and empathetic
- Use natural, conversational language
- Speak at a moderate pace
- Be patient and understanding`;
        }

        async function StartSession() {
            try {
                // Remove any existing close button from previous session
                if (currentCloseButton && currentCloseButton.parentNode) {
                    currentCloseButton.remove();
                    currentCloseButton = null;
                }
                
                // Clear transcript for new session
                clearTranscript();
                
                const selectedVoice = document.getElementById('voiceSelect').value;
                const temperature = parseFloat(document.getElementById('temperatureSlider').value);
                const instructions = buildSystemInstructions();

                console.log(`ğŸš€ Starting session with voice: ${selectedVoice}, temperature: ${temperature}`);

                const response = await fetch(SESSIONS_URL, {
                    method: "POST",
                    headers: {
                        "api-key": API_KEY,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        model: DEPLOYMENT,
                        voice: selectedVoice
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }

                const data = await response.json();
                const sessionId = data.id;
                const ephemeralKey = data.client_secret?.value; 

                console.log("âœ… Ephemeral Key Received");
                console.log("âœ… Session ID: " + sessionId);

                init(ephemeralKey, {
                    voice: selectedVoice,
                    temperature: temperature,
                    instructions: instructions
                }); 

            } catch (error) {
                console.error("Error fetching ephemeral key:", error);
                alert("âŒ Error: " + error.message);
            }
        }

        async function init(ephemeralKey, config) {
            let peerConnection = new RTCPeerConnection();

            // Set up audio playback
            const audioElement = document.createElement('audio');
            audioElement.autoplay = true;
            document.body.appendChild(audioElement);

            peerConnection.ontrack = (event) => {
                audioElement.srcObject = event.streams[0];
                console.log("ğŸ”Š Audio stream connected");
            };

            // Get microphone access
            try {
                const clientMedia = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioTrack = clientMedia.getAudioTracks()[0];
                peerConnection.addTrack(audioTrack);
                console.log("ğŸ¤ Microphone access granted");
            } catch (error) {
                console.error("âŒ Microphone access denied:", error);
                alert("âŒ Microphone access denied: " + error.message);
                return;
            }

            const dataChannel = peerConnection.createDataChannel('realtime-channel');

            dataChannel.addEventListener('open', () => {
                console.log('âœ… Data channel is open');
                updateSession(dataChannel, config);
            });

            dataChannel.addEventListener('message', (event) => {
                const realtimeEvent = JSON.parse(event.data); 
                console.log("ğŸ“© Received event:", realtimeEvent.type, realtimeEvent);
                
                // Handle transcription events for user input
                if (realtimeEvent.type === "conversation.item.input_audio_transcription.completed") {
                    const userText = realtimeEvent.transcript;
                    if (userText && userText.trim()) {
                        addMessageToTranscript('user', userText);
                    }
                }
                
                // Handle Beti's text response (accumulate deltas)
                else if (realtimeEvent.type === "response.audio_transcript.delta") {
                    const delta = realtimeEvent.delta;
                    if (delta) {
                        currentBetiResponse += delta;
                    }
                }
                
                // When response is done, add the complete Beti message
                else if (realtimeEvent.type === "response.audio_transcript.done") {
                    if (currentBetiResponse.trim()) {
                        addMessageToTranscript('beti', currentBetiResponse.trim());
                        currentBetiResponse = ''; // Reset for next response
                    }
                }
                
                // Log session events to console only
                else if (realtimeEvent.type === "session.created") {
                    console.log("âœ… Session created successfully");
                } else if (realtimeEvent.type === "session.updated") {
                    console.log("âœ… Session updated with configuration and transcription enabled");
                } else if (realtimeEvent.type === "error" || realtimeEvent.type === "session.error") {
                    console.error("âŒ Error:", realtimeEvent.error?.message || JSON.stringify(realtimeEvent));
                    alert("âŒ Error: " + (realtimeEvent.error?.message || "Unknown error"));
                }
            });

            dataChannel.addEventListener('close', () => {
                console.log('ğŸ“´ Data channel closed');
            });

            // Establish WebRTC connection
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            const sdpResponse = await fetch(`${WEBRTC_URL}?model=${DEPLOYMENT}`, {
                method: "POST",
                body: offer.sdp,
                headers: {
                    Authorization: `Bearer ${ephemeralKey}`,
                    "Content-Type": "application/sdp",
                },
            });

            if (!sdpResponse.ok) {
                console.error("âŒ WebRTC connection failed:", sdpResponse.status);
                alert("âŒ WebRTC connection failed: " + sdpResponse.status);
                return;
            }

            const answer = { type: "answer", sdp: await sdpResponse.text() };
            await peerConnection.setRemoteDescription(answer);

            console.log("âœ… Connected! You can now speak to the assistant.");

            currentCloseButton = document.createElement('button');
            currentCloseButton.innerText = 'ğŸ›‘ End Session';
            currentCloseButton.onclick = stopSession;
            currentCloseButton.id = 'endSessionButton';
            document.body.appendChild(currentCloseButton);

            function updateSession(dataChannel, config) {
                const event = {
                    type: "session.update",
                    session: {
                        instructions: config.instructions,
                        voice: config.voice,
                        temperature: config.temperature,
                        input_audio_transcription: {
                            model: "whisper-1"
                        },
                        turn_detection: {
                            type: "server_vad",
                            threshold: 0.5,
                            prefix_padding_ms: 300,
                            silence_duration_ms: 500
                        },
                        modalities: ["text", "audio"]
                    }
                };
                
                dataChannel.send(JSON.stringify(event));
                console.log("ğŸ“¤ Configuration sent to AI with transcription enabled");
                
                // Wait a moment for session to be ready, then send Beti's opening greeting
                setTimeout(() => {
                    const greetingEvent = {
                        type: "response.create",
                        response: {
                            modalities: ["text", "audio"],
                            instructions: "Say exactly this in Hebrew: ×”×™×™ ×× ×™ ×‘×˜×™, ×¢× ××™ ×™×© ×œ×™ ××ª ×”×›×‘×•×“?"
                        }
                    };
                    dataChannel.send(JSON.stringify(greetingEvent));
                    console.log("ğŸ‘‹ Sent Beti's opening greeting");
                }, 1000);
            }

            function stopSession() {
                if (dataChannel) dataChannel.close();
                if (peerConnection) peerConnection.close();
                if (audioElement) audioElement.remove();
                peerConnection = null;
                
                // Disable the button and change its appearance
                if (currentCloseButton) {
                    currentCloseButton.disabled = true;
                    currentCloseButton.innerText = 'âœ… Session Ended';
                    currentCloseButton.style.background = '#6c757d';
                    currentCloseButton.style.cursor = 'not-allowed';
                    currentCloseButton.style.opacity = '0.6';
                }
                
                console.log("ğŸ›‘ Session ended");
            }
        }
    </script>
</body>
</html>
